from __future__ import annotations
import os, time, math, re
from datetime import datetime, timezone
from typing import List, Dict, Any
import feedparser

# You can extend/override via env NEWS_SOURCES (comma-separated)
DEFAULT_SOURCES = [
    # Cannabis + crypto/cannatech first
    "https://www.benzinga.com/feeds/rss/markets/cryptocurrency",  # Benzinga crypto (often covers niche)
    "https://mjbizdaily.com/feed/",                               # MJBizDaily (cannabis business)
    # Broad crypto
    "https://www.coindesk.com/arc/outboundfeeds/rss/",            # CoinDesk
    "https://cointelegraph.com/rss",                              # CoinTelegraph
    "https://decrypt.co/feed",                                    # Decrypt
]

KEYWORDS_CANNABIS = [
    r"\bcannabis\b", r"\bweed\b", r"\b420\b", r"\bhemp\b", r"\bTHC\b", r"\bCBD\b",
    r"\bweedcoin\b", r"\bweed coin\b"
]
KEYWORDS_MAJORS = [
    r"\bBTC\b", r"\bBitcoin\b", r"\bETH\b", r"\bEthereum\b",
    r"\bUSDT\b", r"\bUSDC\b", r"\bSOL\b"
]
KEYWORDS_CRYPTO = [
    r"\bcrypto\b", r"\bblockchain\b", r"\bDeFi\b", r"\bWeb3\b", r"\bexchange\b", r"\btoken\b"
]

def _now_ts()->float: return time.time()

def _score(title:str, summary:str)->float:
    text = f"{title} {summary}".lower()
    score = 0.0
    for pat in KEYWORDS_CANNABIS:
        if re.search(pat, text, flags=re.I): score += 5.0
    for pat in KEYWORDS_MAJORS:
        if re.search(pat, text, flags=re.I): score += 2.0
    for pat in KEYWORDS_CRYPTO:
        if re.search(pat, text, flags=re.I): score += 1.0
    # slight boost for shorter titles (readability) and recency applied later
    score += max(0.0, 2.0 - len(title)/140.0)
    return score

def _age_penalty(published_ts: float)->float:
    # Reduce score as it gets older (half-life ~ 24h)
    hours = max(0.0, (_now_ts() - published_ts) / 3600.0)
    return math.exp(-hours / 24.0)

def _norm_item(e)->Dict[str,Any]:
    title = e.get("title","").strip()
    link = e.get("link","").strip()
    summ = (e.get("summary") or e.get("description") or "").strip()
    # published
    ts = None
    if "published_parsed" in e and e["published_parsed"]:
        ts = time.mktime(e["published_parsed"])
    elif "updated_parsed" in e and e["updated_parsed"]:
        ts = time.mktime(e["updated_parsed"])
    else:
        ts = _now_ts()
    return {
        "title": title,
        "url": link,
        "summary": summ,
        "ts": float(ts),
        "source": (e.get("source",{}) or {}).get("title") or e.get("author") or "",
    }

def _dedupe(items: List[Dict[str,Any]])->List[Dict[str,Any]]:
    seen = set(); out=[]
    for it in items:
        key = (it["title"].lower(), it["url"])
        if key in seen: continue
        seen.add(key); out.append(it)
    return out

def _load_feed(url:str)->List[Dict[str,Any]]:
    try:
        d = feedparser.parse(url)
        items = [_norm_item(e) for e in d.entries or []]
        return items
    except Exception:
        return []

def fetch_news(limit:int=5, lane:str="all")->List[Dict[str,Any]]:
    """
    lane: 'all' | 'cannabis' | 'majors' â€” affects scoring emphasis.
    """
    sources = [s.strip() for s in (os.environ.get("NEWS_SOURCES","") or "").split(",") if s.strip()] or DEFAULT_SOURCES
    items: List[Dict[str,Any]] = []
    for src in sources:
        items.extend(_load_feed(src))

    if not items:
        return []

    # score + recency
    for it in items:
        base = _score(it["title"], it["summary"])
        # lane emphasis
        if lane == "cannabis":
            base *= 1.3
        elif lane == "majors":
            # slight favor to majors words already applied in _score
            base *= 1.1
        it["score"] = base * _age_penalty(it["ts"])

    items = sorted(_dedupe(items), key=lambda x: x.get("score",0.0), reverse=True)
    return items[:max(1, min(20, int(limit)))]

